"use client"

import type React from "react"

import { useState } from "react"
import { useSearch } from "@/lib/search-context"
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Upload, FileText } from "lucide-react"
import type { Document } from "@/lib/types"
import Papa from "papaparse"
import { toast } from "react-toastify"
import { formatNumber } from "@/lib/utils"

interface CorpusUploadDialogProps {
  open: boolean
  onOpenChange: (open: boolean) => void
}

export function CorpusUploadDialog({ open, onOpenChange }: CorpusUploadDialogProps) {
  const { addCorpus } = useSearch()
  const [corpusName, setCorpusName] = useState("")
  const [file, setFile] = useState<File | null>(null)
  const [isUploading, setIsUploading] = useState(false)

  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const selectedFile = e.target.files?.[0]
    if (selectedFile) {
      setFile(selectedFile)
      if (!corpusName) {
        setCorpusName(selectedFile.name.replace(/\.[^/.]+$/, ""))
      }
    }
  }

  const handleUpload = async () => {
    if (!file || !corpusName) return

    setIsUploading(true)
    try {
      const text = await file.text()
      const documents: Document[] = []

      // Parse JSON or JSONL format
      if (file.name.endsWith(".json")) {
        let data
        try {
          data = JSON.parse(text)
        } catch (e) {
          toast.error("Invalid JSON format. Please check your file syntax.")
          return
        }

        if (!Array.isArray(data)) {
          toast.error("JSON file must contain an array of documents.")
          return
        }

        if (data.length === 0) {
          toast.error("JSON file is empty. Please provide at least one document.")
          return
        }

        // Validate that documents have required fields
        const invalidDocs = data.filter((item, idx) => !item.text && !item.title)
        if (invalidDocs.length > 0) {
          toast.error(
            `Invalid document format: ${invalidDocs.length} document(s) missing both 'text' and 'title' fields. Each document must have at least a 'text' field.`,
          )
          return
        }

        data.forEach((item) => {
          documents.push({
            id: "", // Placeholder - will be generated by addCorpus
            text: item.text || "",
            title: item.title,
            url: item.url,
          })
        })
      } else if (file.name.endsWith(".jsonl")) {
        const lines = text.split("\n").filter((line) => line.trim())

        if (lines.length === 0) {
          toast.error("JSONL file is empty. Please provide at least one document.")
          return
        }

        const parseErrors: number[] = []
        const invalidDocs: number[] = []

        lines.forEach((line, idx) => {
          try {
            const item = JSON.parse(line)

            // Validate required fields
            if (!item.text && !item.title) {
              invalidDocs.push(idx + 1)
              return
            }

            documents.push({
              id: "", // Placeholder - will be generated by addCorpus
              text: item.text || "",
              title: item.title,
              url: item.url,
            })
          } catch (e) {
            parseErrors.push(idx + 1)
          }
        })

        if (parseErrors.length > 0) {
          toast.error(
            `Failed to parse ${parseErrors.length} line(s) in JSONL file. Lines: ${parseErrors.slice(0, 5).join(", ")}${parseErrors.length > 5 ? "..." : ""}`,
          )
          return
        }

        if (invalidDocs.length > 0) {
          toast.error(
            `${invalidDocs.length} document(s) missing both 'text' and 'title' fields. Each document must have at least a 'text' field.`,
          )
          return
        }
      } else if (file.name.endsWith(".txt")) {
        const chunks = text.split("\n\n").filter((chunk) => chunk.trim())

        if (chunks.length === 0) {
          toast.error("TXT file is empty or has no content separated by double newlines.")
          return
        }

        chunks.forEach((chunk) => {
          documents.push({
            id: "", // Placeholder - will be generated by addCorpus
            text: chunk.trim(),
          })
        })
      } else if (file.name.endsWith(".csv")) {
        const parseResult = Papa.parse(text, {
          header: true,
          skipEmptyLines: true,
          transformHeader: (header) => header.trim().toLowerCase(),
        })

        if (parseResult.errors.length > 0) {
          const criticalErrors = parseResult.errors.filter(
            (err) => err.type === "Quotes" || err.type === "FieldMismatch",
          )
          if (criticalErrors.length > 0) {
            toast.error(`CSV parsing errors: ${criticalErrors[0].message}`)
            return
          }
        }

        const rows = parseResult.data as Record<string, string>[]

        if (rows.length === 0) {
          toast.error("CSV file is empty or has no valid rows.")
          return
        }

        // Check if required 'text' column exists
        if (!("text" in rows[0])) {
          toast.error("CSV must have a 'text' column. Available columns: " + Object.keys(rows[0]).join(", "))
          return
        }

        // Validate that rows have text content
        const emptyRows = rows.filter((row, idx) => !row.text || row.text.trim() === "")
        if (emptyRows.length === rows.length) {
          toast.error("All rows in CSV have empty 'text' fields.")
          return
        }

        // Create documents from parsed rows
        rows.forEach((row) => {
          if (row.text && row.text.trim()) {
            documents.push({
              id: "", // Placeholder - will be generated by addCorpus
              text: row.text || "",
              title: row.title || undefined,
              url: row.url || undefined,
            })
          }
        })

        console.log(`[v0] Parsed ${documents.length} documents from CSV with ${rows.length} rows`)
      }

      if (documents.length === 0) {
        toast.error("No valid documents found in file. Please check the format requirements.")
        return
      }

      await addCorpus(corpusName, documents)
      toast.success(`Successfully uploaded corpus "${corpusName}" with ${formatNumber(documents.length)} documents`)
      onOpenChange(false)
      setCorpusName("")
      setFile(null)
    } catch (error) {
      console.error("Error uploading corpus:", error)
      toast.error(`Error uploading corpus: ${error instanceof Error ? error.message : "Unknown error"}`)
    } finally {
      setIsUploading(false)
    }
  }

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-[500px] bg-card border-border">
        <DialogHeader>
          <DialogTitle className="text-foreground">Upload Custom Corpus</DialogTitle>
          <DialogDescription className="text-muted-foreground">
            Upload a JSON, JSONL, CSV, or TXT file containing your documents. Each document must have at least a text
            field.
          </DialogDescription>
        </DialogHeader>
        <div className="grid gap-4 py-4">
          <div className="grid gap-2">
            <Label htmlFor="corpus-name" className="text-foreground">
              Corpus Name
            </Label>
            <Input
              id="corpus-name"
              value={corpusName}
              onChange={(e) => setCorpusName(e.target.value)}
              placeholder="My Custom Corpus"
              className="bg-secondary border-border text-foreground"
            />
          </div>
          <div className="grid gap-2">
            <Label htmlFor="file-upload" className="text-foreground">
              File
            </Label>
            <div className="flex items-center gap-2">
              <Input
                id="file-upload"
                type="file"
                accept=".json,.jsonl,.txt,.csv"
                onChange={handleFileChange}
                className="bg-secondary border-border text-foreground"
              />
            </div>
            {file && (
              <div className="flex items-center gap-2 text-sm text-muted-foreground">
                <FileText className="h-4 w-4" />
                <span>{file.name}</span>
              </div>
            )}
          </div>
          <div className="text-xs text-muted-foreground space-y-1">
            <p>Supported formats:</p>
            <ul className="list-disc list-inside space-y-1 ml-2">
              <li>JSON: Array of objects with text (required), title (optional), url (optional)</li>
              <li>JSONL: One JSON object per line with text field</li>
              <li>CSV: Comma-separated values with 'text' column (required), title and url columns (optional)</li>
              <li>TXT: Plain text split by double newlines</li>
            </ul>
          </div>
        </div>
        <DialogFooter>
          <Button variant="outline" onClick={() => onOpenChange(false)} className="border-border">
            Cancel
          </Button>
          <Button
            onClick={handleUpload}
            disabled={!file || !corpusName || isUploading}
            className="bg-primary text-primary-foreground"
          >
            {isUploading ? (
              <>
                <Upload className="mr-2 h-4 w-4 animate-pulse" />
                Uploading...
              </>
            ) : (
              <>
                <Upload className="mr-2 h-4 w-4" />
                Upload
              </>
            )}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  )
}
